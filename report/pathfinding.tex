\documentclass[12pt, a4paper]{article}

% Preamble

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage[parfill]{parskip}

\usepackage[hidelinks]{hyperref}
\bibliographystyle{ieeetr}
\usepackage{courier}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\title{Pathfinding, PKD 2014}
\author{Babak Mohebbolhoggeh, Nils Lerin and Robin Eklind}

% Document

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

% === [ Introduction ] =========================================================

\section{Introduction}

Pathfinding is the act of locating a path from point A to point B. A common
special case of pathfinding is concerned with locating the shortest possible
path between two points. Pathfinding has many applications and while some are
obvious, such as map directions, others are less apparent. For instance some
network protocols use pathfinding to locate efficient routes for network
traffic.

% --- [ Purpose ] --------------------------------------------------------------

\subsection{Purpose}

There are many ways to implement pathfinding algorithms, each with its own
benefits and drawbacks. Our goal with this project is to research various
pathfinding algorithms and highlight their strengths and weaknesses.

We implement the Dijkstra algorithm since it's a simple pathfinding algorithm,
which is naive but easy to grasp. For performance reasons we implement the A*
algorithm, which has become the de facto algorithm in game development
\cite{astar1, defacto}.

Another goal with this project is to implement a minimal interface for
performing pathfinding.

% === [ Pathfinding ] ==========================================================

\section{Pathfinding}
\label{Pathfinding}

Most pathfinding algorithms can be described using graph theory. Each node of a
graph represents a walkable cell and the edge between two nodes connects them
and makes it possible to perform a step from one node to the other. The concept
of edge costs captures the time it takes for an entity to step from one node to
another, which may vary depending on the terrain of the edge and other factors.

% Historic (Dijkstra one of the first, A* somewhere during the end of the 70is).

% Graph theory.

% More examples and use cases.

% Mention many different pathfinding algorithms.

% The effects of edge costs.
%    Shortest path, best path, stealth units.

% === [ Design ] ===============================================================

\section{Design}
Our solution for pathfinding works on a 2d grid, where each tile has a (x,y) coordinate and is considered to be either walkable or not. Given the coordinates for start (A) and end (B) tiles our program finds a shortest path and outputs the coordinates of the tiles to traverse in order to get from A to B. The program is divided into seperate components that each perform one of the steps involved.

\textbf{Tilegrid}

Responsible for reading the map data from files and making it available to the program. Implements method \textit{make} which takes as argument the path to a file, which includes the tiles for a map, and returns a \textit{tilegrid} data structure that holds it's contents. The file is comma-seperated ascii file of integers that represents a tile and it's value, the type (wooden floor, grass, concrete wall etc). Each row holds one horizontal set of tiles and it's length is considered the width of the map while the number of rows is considered the height.
\\Example of a map of width 4 and height 3 and two different tiles; 0 and 1

\texttt{1,0,1,1,\\
0,0,0,1,\\
1,1,1,1,\\
}

A second method \textit{merge} is used to merge two layers of map-data. It takes two tilegrids and returns a tilegrid where every tile has the same value as that in the second tilegrid unless that is a value of 0, then it has the value of that in the first tilegrid. We decided to support this because one popular tile map-editor\cite{mapeditor} builds levels in layers this way.

\textbf{Grid}

A similar datastructure is what we call a \textit{grid}. It's a 2d grid of boolean values where each tile is simply true if walkable or false for non-walkable. We include a method for generating a grid out of a tilegrid and a file which contains the values of walkable tiles. This way a user of our program can have multiple files which specify a different set of units that can traverse a different set of tiles of the same map and generate a different grid for each one. In the interface we also have methods for checking if a tile is walkable, getting walkable adjacent tiles to a tile as well as getting the dimensions of a grid. We chose Array2 as the underlying datastructure of the grid because we needed element access in constant time and Array2 provides a convenient way of accessing elements using 2d coordinates.

\textbf{Graph}




% General design description.

% The project have been divided into distinct components, below are the major
% ones:
% * vector2. (datatype and interface of 2d array)
% * grid/tilegrid. (datatype and interface of grid)
% * graph. (datatype and interface of graph)
% * pqueue/pqueue_list/queue. (datatype and interface of pqueue)
% * pathfinding. (datatype and interface of pathfinder)
% * pretty.

\subsection{Design choices}

% Array vs list of lists vs ... Graphs vs 2d-arrays.

% Deliberate choice to perform expensive preprocessing of the graph so that the
% pathfinding itself can be faster.

% But we do not preprocess edge costs.

% Prioriy queues: list (simple), binomial heaps (hopefully fast).

% Number of directions (8 directions).

% ~~~ [ Cutting corners ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The pathfinding algorithm can either allow or forbit diagonal steps to cut
corners. Obviously this decision may affect the shortest path. \cite{astar2}

% It's not perfect, but the code was structured so a future change wouldn't
% require an extensive rewrite. Special concideration was made to make it easy
% to extend from (x, y) to (x, y, z).

% === [ Algorithms ] ===========================================================

\section{Algorithms}

% --- [ Dijkstra ] -------------------------------------------------------------

\subsection{Dijkstra}

% How it works.

% Backtracking

% Useful to find the shortest path of multiple targets, or targets at unknown
% coordinates.

% Its major drawback is performace...

% Time complexity.

% --- [ A* ] -------------------------------------------------------------------

\subsection{A*}

% How it works.

The main idea behind the A* algorithm is to use a heuristic function which makes
an educated guess about the distance of a node to the goal. Using this
information it is able prioritize the processing of nodes which are more likely
to bring you closer to the goal. This reduces the number of nodes which have to
be processed in average and therefore decreases the total runtime of the average
case.

% ~~~ [ Heuristics ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% TODO: rewrite section Heuristics.

\subsubsection{Heuristics}
\label{Heuristics}

\textit{Heuristics using Manhattan distance}

If the pathfinding algorithm overestimates the distance H it may fail to find
the shortest path. For these cases we call the heuristics inadmissible.
\cite{astar2}

\textit{Diagonal heuristics}

Instead of using pure Manhattan distance for the H cost we could use a hybrid
between the Manhattan distance and ''as the crow flies''.

\textit{Example:} Let 's' and 'g' represent the start and goal locations
respectively. Let the cost of a horizontal or vertical step be 10 and the cost
of a diagonal step be 14 ($ \floor{10 \sqrt{2}} $).

\texttt{+-------+ \\
|.....g.| \\
|.s.....| \\
+-------+}

The cost using Manhattan distance between 's' and 'g' is $ 1*10 + 4*10 = 50 $,
since there is one vertical and four horizontal steps from 's' to 'g'.

Using a hybrid heuristic we could combine a horizontal and a vertical step into
a diagonal step which would cost 14 instead of 10+10=20. Using this method the
heuristic could no longer be inadmissible.

The cost using a hybrid heuristic would in this case be $ 1*14 + 3*10 = 44 $,
since there is one diagonal and three horizontal steps from 's' to 'g'.

\textit{Inadmissible heuristics}

% F, G, H costs.

\subsubsection{Edges costs}

In order to prioritize the processing of nodes the A* algorithm keeps track of
three different cost values for each node in the graph, namely \textit{F},
\text{G} and \text{H}.

The \textit{G} value of a node \textit{C} represents the cost of traversing the
edges from the start node \textit{S} to the current node \textit{C} along a
given path. It is important to note that there may be more than one path from
\textit{S} to \textit{C}; more about this in section \ref{Tracking node visits}.

The \textit{H} value of a node \textit{C} is given by the estimated cost of
traveling from \textit{C} to the end node \textit{E}. This estimation is given
by a heuristic function, which is further described in section \ref{Heuristics}.

The \textit{F} value of a node \textit{C} is given by the sum of the \textit{G}
and \textit{H} cost of \textit{C}.

To summarize:
\begin{itemize}
	\item \textit{F}: $ G + H $.
	\item \textit{G}: the cost of traversing the edges from \textit{S} to
	\textit{C}.
	\item \textit{H}: the estimated cost of traversing the edges from \textit{C}
	to \textit{E}.
\end{itemize}

% Open list, closed list (colors).

\subsubsection{Tracking node visits}
\label{Tracking node visits}

It is important to keep track of visited nodes so that no node is processed more
than once.

% Time complexity.

% ~~~ [ Priority queues ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Priority queues}

\begin{enumerate}
\item{List}
\item{Binomial Heap}
\end{enumerate}

\textit{Similarities to Dijkstra}

% The Dijkstra algorithm could be implemented using A* with a heuristic function
% which always returns 0.


% ~~~ [ Multiple shortest paths ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{One out of multiple shortest paths}

When two nodes have the same F score one must be chosen over the other. This
choise will not affect the length of the path, but it may affect the path
itself. Another way to put this is that depending on how ties are treated two
different implementations of the A* algorithm may find different paths of equal
length. \cite{astar2}

% === [ User's Manual ] ========================================================

\section{User's Manual}

% TODO: Use cases, examples...

% ref: demo.sml

% Mention the files and what content they contain. Mention the most important
% functions and their arguments.

% === [ Analysis and discussion ] ==============================================

\section{Analysis and discussion}

% Implementation analysis.

% Test cases, how the we verify that the implementation is correct?

% Is there anything that doesn't work. It is possible to walk thorugh diagonal
% walls.

% Benchmarks. Is A* measurabley more performable than Dijkstra. How does the
% performance of list and binomal heaps differ.

\subsection{Future work}

% Preprocess edge costs.

% Disallow diagonal walks through walls.

% Pathfinding in the third dimension.

% Hot queue.

% Formal verifications.

% Make an interlanguage bridge to make the SML API callable from C. ref: mlton

% Make purely functional (if we don't finish this) and measure the performance
% impact.

\pagebreak

\bibliography{references}

\end{document}
