\documentclass[12pt, a4paper]{article}

% Preamble

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage[parfill]{parskip}

\usepackage[hidelinks]{hyperref}
\bibliographystyle{ieeetr}
\usepackage{courier}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\title{Pathfinding, PKD 2014}
\author{Babak Mohebbolhoggeh, Nils Lerin and Robin Eklind}

% Document

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

% === [ Introduction ] =========================================================

\section{Introduction}

Pathfinding is the act of locating a path from point A to point B. A common
special case of pathfinding is concerned with locating the shortest possible
path between two points. Pathfinding has many applications and while some are
obvious, such as map directions, others are less apparent. For instance some
network protocols use pathfinding to locate efficient routes for network
traffic.

% --- [ Purpose ] --------------------------------------------------------------

\subsection{Purpose}

There are many ways to implement pathfinding algorithms, each with its own
benefits and drawbacks. Our goal with this project is to research various
pathfinding algorithms and highlight their strengths and weaknesses.

We implement the Dijkstra algorithm since it's a simple pathfinding algorithm,
which is naive but easy to grasp. For performance reasons we implement the A*
algorithm, which has become the de facto algorithm in game development
\cite{astar1, defacto}.

Another goal with this project is to implement a minimal interface for
performing pathfinding.

% === [ Pathfinding ] ==========================================================

\section{Pathfinding}
\label{Pathfinding}

Most pathfinding algorithms can be described using graph theory. Each node of a
graph represents a walkable cell and the edge between two nodes connects them
and makes it possible to perform a step from one node to the other. The concept
of edge costs captures the time it takes for an entity to step from one node to
another, which may vary depending on the terrain of the edge and other factors.

% Historic (Dijkstra one of the first, A* somewhere during the end of the 70is).

% Graph theory.

% More examples and use cases.

% Mention many different pathfinding algorithms.

% The effects of edge costs.
%    Shortest path, best path, stealth units.

% === [ Design ] ===============================================================

\section{Design}
Our solution for pathfinding works on a 2d grid, where each tile has a (x,y) coordinate and is considered to be either walkable or not. Given the coordinates for start (A) and end (B) tiles our program finds a shortest path and outputs the coordinates of the tiles to traverse in order to get from A to B. The program is divided into seperate components that each perform one of the steps involved.

\subsection{Components}
\subsubsection{Tilegrid}

Responsible for reading the map data from files and making it available to the program. Implements function \textit{make} which takes as argument the path to a file, which includes the tiles for a map, and returns a \textit{tilegrid} data structure that holds it's contents. The file is comma-seperated ascii file of integers that represents a tile and it's value, the type (wooden floor, grass, concrete wall etc). Each row holds one horizontal set of tiles and it's length is considered the width of the map while the number of rows is considered the height.
\\Example of a map of width 4 and height 3 and two different tiles; 0 and 1

\texttt{1,0,1,1,\\
0,0,0,1,\\
1,1,1,1,\\
}

A second function \textit{merge} is used to merge two layers of map-data. It takes two tilegrids and returns a tilegrid where every tile has the same value as that in the second tilegrid unless that is a value of 0, then it has the value of that in the first tilegrid. We decided to support this because one popular tile map-editor\cite{mapeditor} builds levels in layers this way.

\subsubsection{Grid}

A similar datastructure is what we call a \textit{grid}. It's a 2d grid of boolean values where each tile is simply true if walkable or false for non-walkable. We include a function for generating a grid out of a tilegrid and a file which contains the values of walkable tiles. This way a user of our program can have multiple files which specify a different set of units that can traverse a different set of tiles of the same map and generate a different grid for each one. In the interface we also have methods for checking if a tile is walkable, getting walkable adjacent tiles of a tile as well as getting the dimensions of a grid. We chose Array2 as the underlying datastructure of the grid because we needed element access in constant time, we could have chosen a Vector but Array2 provides a convenient way of accessing elements using 2d coordinates.

\subsubsection{Graph}
Our abstract datatype \textit{graph} is what holds the graph of nodes. A node is a walkable tile with edges that connects it to adjacent walkable nodes, it also has a component to hold arbitrary data needed by the pathfinder algorithms. We provide methods to create a graph from a grid, update and get methods for a node provided it's coordinates and a copy function to make a new copy of the whole graph. We could have skipped this datatype and have our pathfinders work directly with a grid but we dicided to do this preprocessing and create a node graph so that we could re-use it and do multiple pathfindings without having to calculate adjacent nodes each time. In agreement with our supervisor, we chose Array2 as the underlaying datastructure for the graph because we needed to efficiently update and get data from a set of nodes and Array2 does this in constant time with 2d coordinates as input.

\subsubsection{Pathfinder}
We provide two different pathfinders that use different algorithms for finding the shortest path, A* and Dijsktra (see section \ref{Algorithms}). Each one has a function for finding a path as well as creating a graph that includes the extra data needed by the algorithm. Once the graph has been created it can be sent to the function that does the actual pathfinding, along with start and end coordinates, and the path is sent back. In the case when a path can't be found the methods will return NONE. We decided to provide two different algorithms mainly because of interest for how they work but also to test their performance (see section \ref{Analysis}).

\subsubsection{Priority queue}
The A* algorithm needs to keep a queue with nodes to process and sort them depending on a key value, for this we created a datatype called queue. We provide methods to create an empty queue, insert and update nodes and a function to extract the node with the lowest key. We decided to create two different implementations, one using a binomial heap and one using a list (see section \ref{Priority queues}) to see how they would fair performance wise.

\subsubsection{Pretty}
Pretty has methods to display a grid, or a grid and the path as return by a pathfinder, in the the form of ascii art in the standard output.




% General design description.

% The project have been divided into distinct components, below are the major
% ones:
% ----- * vector2. (datatype and interface of 2d array)
% ----- * grid/tilegrid. (datatype and interface of grid)
% ----- * graph. (datatype and interface of graph)
% ----- * pqueue/pqueue_list/queue. (datatype and interface of pqueue)
% ----- * pathfinding. (datatype and interface of pathfinder)
% ----- * pretty.

\subsection{Design choices}

% ----- Array vs list of lists vs ... Graphs vs 2d-arrays.

% ------ Deliberate choice to perform expensive preprocessing of the graph so that the
% ------ pathfinding itself can be faster.

% But we do not preprocess edge costs.

% Prioriy queues: list (simple), binomial heaps (hopefully fast).

% Number of directions (8 directions).

% ~~~ [ Cutting corners ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The pathfinding algorithm can either allow or forbit diagonal steps to cut
corners. Obviously this decision may affect the shortest path. \cite{astar2}

% It's not perfect, but the code was structured so a future change wouldn't
% require an extensive rewrite. Special concideration was made to make it easy
% to extend from (x, y) to (x, y, z).

% === [ Algorithms ] ===========================================================

\section{Algorithms}
\label{Algorithms}

% --- [ Dijkstra ] -------------------------------------------------------------

\subsection{Dijkstra}

% How it works.

% Backtracking

% Useful to find the shortest path of multiple targets, or targets at unknown
% coordinates.

% Its major drawback is performace...

% Time complexity.

% --- [ A* ] -------------------------------------------------------------------

\subsection{A*}

% How it works.

The main idea behind the A* algorithm is to use a heuristic function which makes
an educated guess about the distance of a node to the end node. Using this
information it is able prioritize the processing of nodes which are more likely
to bring you closer to the end node. This reduces the number of nodes which have
to be processed in average and therefore decreases the total runtime of the
average case.

% ~~~ [ Heuristics ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% TODO: rewrite section Heuristics.

\subsubsection{Heuristics}
\label{Heuristics}

The importance of using a good heuristic function for the A* algorithm should
not be understated. If the heuristic function overestimates the cost \textit{H}
to traverse from a node \textit{C} to the end node \textit{E} the A* algorithm
may fail to locate the shortest path. For these cases we call the heuristic
function inadmissible \cite{astar2}. On the other hand, if the heuristic
function underestimates \textit{H} many unneccesary nodes will be processed by
the A* algorithm, which gives it a runtime complexity similar to that of the
Dijkstra algorithm. The \textit{H} cost is further described in section
\ref{Edge costs}.

\textit{Heuristics using Manhattan distance}

For two-dimensional grids the most straightforward measurement of the heuristic
\textit{H} cost is the Manhattan distance \cite{manhattan}. Think of it as the
distance traveled by a taxicab in Manhattan, where it has to follow horizontal
and vertical streets to reach its destination and isn't allowed to travel
diagonally.

Heuristic functions based on the Manhattan distance works great if units are
only allowed to move horizontally and vertically. Manhattan distance heuristics
may overestimate the \textit{H} costs if units are allowed to move diagonally as
well. As stated above this can result in suboptimal paths since the heuristic
function is inadmissible. To resolve this issue, lets take a look at diagonal
heuristics.

\textit{Diagonal heuristics}

Instead of using pure Manhattan distance for the H cost we could use a hybrid
between the Manhattan distance and ''as the crow flies''.

\textit{Example:} Let 's' and 'g' represent the start and end locations
respectively. Let the cost of a horizontal or vertical step be 10 and the cost
of a diagonal step be 14 ($ \floor{10 \sqrt{2}} $).

\texttt{+-------+ \\
|.....g.| \\
|.s.....| \\
+-------+}

The cost using Manhattan distance between 's' and 'g' is $ 1*10 + 4*10 = 50 $,
since there is one vertical and four horizontal steps from 's' to 'g'.

Using a hybrid heuristic we could combine a horizontal and a vertical step into
a diagonal step which would cost 14 instead of 10+10=20. Using this method the
heuristic could no longer be inadmissible.

The cost using a hybrid heuristic would in this case be $ 1*14 + 3*10 = 44 $,
since there is one diagonal and three horizontal steps from 's' to 'g'.

\textit{Inadmissible heuristics}

% F, G, H costs.

\subsubsection{Edge costs}
\label{Edge costs}

In order to prioritize the processing of nodes the A* algorithm keeps track of
three different cost values for each node in the graph, namely \textit{F},
\text{G} and \text{H}.

The \textit{G} value of a node \textit{C} represents the cost of traversing the
edges from the start node \textit{S} to the current node \textit{C} along a
given path. It is important to note that there may be more than one path from
\textit{S} to \textit{C}; more about this in section \ref{Tracking node visits}.

The \textit{H} value of a node \textit{C} is given by the estimated cost of
traveling from \textit{C} to the end node \textit{E}. This estimation is given
by a heuristic function, which is further described in section \ref{Heuristics}.

The \textit{F} value of a node \textit{C} is given by the sum of the \textit{G}
and \textit{H} cost of \textit{C}.

To summarize:
\begin{itemize}
	\item \textit{F}: $ G + H $.
	\item \textit{G}: the cost of traversing the edges from \textit{S} to
	\textit{C}.
	\item \textit{H}: the estimated cost of traversing the edges from \textit{C}
	to \textit{E}.
\end{itemize}

% Open list, closed list (colors).

\subsubsection{Tracking node visits}
\label{Tracking node visits}

It is important to keep track of visited nodes so that no node is processed more
than once.

% Time complexity.

% ~~~ [ Priority queues ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Priority queues}
\label{Priority queues}

A priority queue is a queue of elements with a priority. The element with the highest priority is always the first element to be taken off the list. We use a value 'key'  for each element to represent the priority, the lower key the higher the priority. Every element also has a unique identifier which we can use to find an element and update the priority.  There are numerous ways to implement priority queues and we have created two implementations.

\begin{enumerate}
\item{List}
A one dimensional list where the elements are ordered by rising key value. Popping the element with the highest priority from the queue is just a matter of taking the first element in the list which is a constant time operation. Elements are inserted at the right position by comparing the key of the element to insert with every consecutive element from the beginning of the list until a element with a higher key value is found. Updating the priority of a element is a matter of looking through the list, element by element, until we find one with a specific identifier, removing that from the list and inserting it again with the new priority. Inserting and updating (remove and insert) are both operations that take linear time because we potentially have to look at every element in the list.

\item{Binomial Heap}
A binomial min-heap is a list of binomial trees that satisfy the min-heap property such that the key of each non-root is a least the key of it's parent.  Fully explaining a binomial heap however is not within the scope of this report.

\end{enumerate}

\textit{Similarities to Dijkstra}

% The Dijkstra algorithm could be implemented using A* with a heuristic function
% which always returns 0.


% ~~~ [ Multiple shortest paths ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{One out of multiple shortest paths}

When two nodes have the same F score one must be chosen over the other. This
choise will not affect the length of the path, but it may affect the path
itself. Another way to put this is that depending on how ties are treated two
different implementations of the A* algorithm may find different paths of equal
length. \cite{astar2}

% === [ User's Manual ] ========================================================

\section{User's Manual}

% TODO: Use cases, examples...

% ref: demo.sml

% Mention the files and what content they contain. Mention the most important
% functions and their arguments.

% === [ Analysis and discussion ] ==============================================

\section{Analysis and discussion}
\label{Analysis}

% Implementation analysis.

% Test cases, how the we verify that the implementation is correct?

% Is there anything that doesn't work. It is possible to walk thorugh diagonal
% walls.

% Benchmarks. Is A* measurabley more performable than Dijkstra. How does the
% performance of list and binomal heaps differ.

\subsection{Future work}

% Preprocess edge costs.

% Disallow diagonal walks through walls.

% Pathfinding in the third dimension.

% Hot queue.

% Formal verifications.

% Make an interlanguage bridge to make the SML API callable from C. ref: mlton

% Make purely functional (if we don't finish this) and measure the performance
% impact.

\pagebreak

\bibliography{references}

\end{document}
