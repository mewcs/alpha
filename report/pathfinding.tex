\documentclass[12pt, a4paper]{article}

% Preamble

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage[parfill]{parskip}

\usepackage[hidelinks]{hyperref}
\bibliographystyle{ieeetr}
\usepackage{courier}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\title{Pathfinding, PKD 2014}
\author{Babak Mohebbolhoggeh, Nils Lerin and Robin Eklind}

% Document

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

% === [ Introduction ] =========================================================

\section{Introduction}

Pathfinding is the act of locating a path from point A to point B. A common
special case of pathfinding is concerned with locating the shortest possible
path between two points. Pathfinding has many applications and while some are
obvious, such as map directions, others are less apparent. For instance some
network protocols use pathfinding to locate efficient routes for network
traffic.

% --- [ Purpose ] --------------------------------------------------------------

\subsection{Purpose}

There are many ways to implement pathfinding algorithms, each with its own
benefits and drawbacks. Our goal with this project is to research various
pathfinding algorithms and highlight their strengths and weaknesses.

We implement the Dijkstra algorithm since it's a simple pathfinding algorithm,
which is naive but easy to grasp. For performance reasons we implement the A*
algorithm, which has become the de facto algorithm in game development
\cite{astar1, defacto}.

Another goal with this project is to implement a minimal interface for
performing pathfinding.

% === [ Pathfinding ] ==========================================================

\section{Pathfinding}
\label{Pathfinding}

% Graph theory.

Most pathfinding algorithms can be described using graph theory. Each node of a
graph represents a walkable cell and the edge between two nodes connects them
and makes it possible to perform a step from one node to the other. The concept
of edge costs captures the time it takes for an entity to step from one node to
another, which may vary depending on the terrain of the edge and other factors.

% Historic (Dijkstra one of the first, A* somewhere during the end of the 70is).
% skip?

% More examples and use cases.
% skip?

% Mention many different pathfinding algorithms.
% Specialize at 3d pathfinding. Doesn't specialize at finding the shortest path.
% First multiple paths, or find the shortest path to any of a number of end nodes.
% ...

% Other applications of edge costs.
%    Shortest path, best path, stealth units.

% === [ Design ] ===============================================================

\section{Design}
Our solution for pathfinding operates on a 2d grid, where each tile has a (x,y) coordinate and is considered to be either walkable or non-walkable. Given the coordinates for start (A) and end (B) tiles our program finds a shortest path and outputs the coordinates of the tiles to traverse in order to get from A to B. The program is divided into seperate components that each perform one of the steps involved.

\subsection{Components}
\subsubsection{Tilegrid}

Responsible for reading the map data from files and making it available to the program. Implements function \textit{make} which takes as argument the path to a file, which includes the tiles for a map, and returns a \textit{tilegrid} data structure that holds it's contents. The file is a comma-seperated ascii file of integers that represents a tile and it's value, the type (wooden floor, grass, concrete wall etc). Each row holds one horizontal set of tiles and it's length is considered the width of the map while the number of rows is considered the height.
\begin{figure}[htbp]
\centering
\texttt{1,0,1,1,\\
0,0,0,1,\\
1,1,1,1,\\
}
\caption{Map of width 4 and height 3 and two different tiles; 0 and 1}
\end{figure}

A second function \textit{merge} is used to merge two layers of map-data. It takes two tilegrids and returns a tilegrid where every tile has the same value as that in the second tilegrid unless that is a value of 0, then it has the value of that in the first tilegrid. We decided to support this because one popular tile map-editor\cite{mapeditor} builds levels in layers this way.

\subsubsection{Grid}

A similar datastructure is what we call a \textit{grid}. It's a 2d grid of boolean values where each tile is true if walkable or false for non-walkable. We include a function for generating a grid out of a tilegrid together with a file which contains the values of tiles that should be considered as walkable. This way a user of our program can have multiple files which specify a different set of units that can traverse a different set of tiles of the same map and generate a different grid for each one. In the interface we also have functions for checking if a tile is walkable, getting walkable adjacent tiles of a tile as well as getting the dimensions of a grid. We chose Array2 as the underlying datastructure of the grid because we needed element access in constant time, we could have chosen a Vector but Array2 provides a convenient way of accessing elements using 2d coordinates.

\subsubsection{Graph}
Our abstract datatype \textit{graph} is what holds the graph of nodes. A node is a walkable tile with edges that connects it to adjacent walkable nodes, it also has a component to hold arbitrary data needed by the pathfinder algorithms. We provide functions to create a graph from a grid, update and get functions for a node provided its coordinates and a copy function to make a new copy of the whole graph. We could have skipped this datatype and have our pathfinders work directly with a grid but we dicided to do this preprocessing and create a node graph so that we could re-use it and do multiple pathfindings without having to calculate adjacent nodes each time. In agreement with our supervisor, we chose Array2 as the underlaying datastructure for the graph because we needed to efficiently update and get data from an element and Array2 does this in constant time with 2d coordinates as input.

\subsubsection{Pathfinder}
We provide two different pathfinders that use different algorithms for finding the shortest path, A* and Dijsktra (see section \ref{Algorithms}). Each one has a function for finding a path as well as creating a graph that includes the extra data needed by the algorithm. Once the graph has been created it can be sent to the function that does the actual pathfinding, along with start and end coordinates, and the path is sent back. In the case when a path can't be found the functions will return NONE. We decided to provide two different algorithms mainly because of interest for how they work but also to test their performance (see section \ref{Analysis}).

\subsubsection{Priority queue}
The A* algorithm needs to keep a queue with nodes to process and sort them depending on a key value, for this we created a datatype called queue. We provide functions to create an empty queue, insert and update nodes and a function to extract the node with the lowest key. We decided to create two different implementations, one using a binomial heap and one using a list (see section \ref{Priority queues}) to see how they would fair performance wise.

\subsubsection{Pretty}
Pretty has functions to display a grid, or a grid and the path as return by a pathfinder, in the the form of ascii art in the standard output.




% General design description.

% The project have been divided into distinct components, below are the major
% ones:
% ----- * vector2. (datatype and interface of 2d array)
% ----- * grid/tilegrid. (datatype and interface of grid)
% ----- * graph. (datatype and interface of graph)
% ----- * pqueue/pqueue_list/queue. (datatype and interface of pqueue)
% ----- * pathfinding. (datatype and interface of pathfinder)
% ----- * pretty.

\subsection{Design choices}

% ----- Array vs list of lists vs ... Graphs vs 2d-arrays.

% ------ Deliberate choice to perform expensive preprocessing of the graph so that the
% ------ pathfinding itself can be faster.

% But we do not preprocess edge costs.

% Prioriy queues: list (simple), binomial heaps (hopefully fast).

% Number of directions (8 directions).

% ~~~ [ Cutting corners ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The pathfinding algorithm can either allow or forbit diagonal steps to cut
corners. Obviously this decision may affect the shortest path. \cite{astar2}

% It's not perfect, but the code was structured so a future change wouldn't
% require an extensive rewrite. Special concideration was made to make it easy
% to extend from (x, y) to (x, y, z).

% === [ Algorithms ] ===========================================================

\section{Algorithms}
\label{Algorithms}

% --- [ Dijkstra ] -------------------------------------------------------------

\subsection{Dijkstra}

% How it works.

Dijkstra's algorithm can basically be seen as variation of a breadth-first search. The algorithm starts off
on a start node and expands uniformly from it in all (eight in our case) directions until it hits
the end node. No path is found if all searchable nodes from the start node have been explored and
the end node still hasn't been found.

To describe this in a more detailed step-by-step fashion, we start off by creating an empty
open list (represented by a queue(insert ref to slides?) in our implementation).
This open list will hold all nodes which we come across and that need to be checked out.
Our next step is to push the start node into the open list and give it a cost value, which
in our case will be 0. Once that is done, we simply follow these steps:

As long as the open list is not empty:

\begin{enumerate}
\item Remove the head of the open list(or dequeue if queue). This is now our current node.
\item Check if the current node is the same as the end node. If it is, then that means we're
done.
\item For every adjacent node to the current node, perform these steps:
a) If the adjacent node is not present in the open list and does not have a value of its own
i.e., it has not been checked, give it a cost value and append(enqueue) it to the open list.
This cost value will be equal to the current node's value added with 10 if the adjacent node
is located either horizontally or vertically from the current node, and 14 if diagonally.
b) If the adjacent node is present in the open list, then give a tentative value to the
cost value of the current node, added with the distance to the adjacent node (10 or 14 depending on its location).
Compare this tentative value to the value of the adjacent node and then assign the smaller of the two values.
\item Go back to step 1.
\end{enumerate}

Once we've reached the end node, we start backtracking to find the path. To backtrack, we first
pick the end node and check all of its adjacent nodes to find the one with the smallest cost value. Once we've
located the node with the smallest cost, we save its location and repeat the last step. This is repeated until we've arrived
back on the start node, at which point we've accumulated a list containing the nodes in a shortest path.

While Dijkstra's algorithm will always find a shortest path, assuming one exists, its
major drawback is performance. Which leads us to the greener pastures of...


% Useful to find the shortest path of multiple targets, or targets at unknown
% coordinates.

% Time complexity.
% skip?

% --- [ A* ] -------------------------------------------------------------------

\subsection{A*}

% How it works.

The main idea behind the A* algorithm is to use a heuristic function which makes
an educated guess about the distance of a node to the end node. Using this
information it is able to prioritize the processing of nodes which are more
likely to bring you closer to the end node. This reduces the number of nodes
which have to be processed in average and therefore decreases the total runtime
of the average case.

% ~~~ [ Heuristics ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Heuristics}
\label{Heuristics}

The importance of using a good heuristic function for the A* algorithm should
not be understated. If the heuristic function overestimates the cost \textit{H}
to traverse from a node \textit{C} to the end node \textit{E} the A* algorithm
may fail to locate the shortest path. For these cases we call the heuristic
function inadmissible \cite{astar2}. On the other hand, if the heuristic
function underestimates \textit{H} many unneccesary nodes will be processed by
the A* algorithm, which gives it a runtime complexity similar to that of the
Dijkstra algorithm. The \textit{H} cost is further described in section
\ref{Edge costs}.

\textit{Heuristics using Manhattan distance}

For two-dimensional grids the most straightforward measurement of the heuristic
\textit{H} cost is the Manhattan distance \cite{manhattan}. Think of it as the
distance traveled by a taxicab in Manhattan, where it has to follow horizontal
and vertical streets to reach its destination and isn't allowed to travel
diagonally.

Heuristic functions based on the Manhattan distance works great if units are
only allowed to move horizontally and vertically. Manhattan distance heuristics
may overestimate the \textit{H} costs if units are allowed to move diagonally as
well. As stated above this can result in suboptimal paths since the heuristic
function is inadmissible. To resolve this issue, lets take a look at diagonal
heuristics.

\textit{Diagonal heuristics}

A diagonal heuristic uses a hybrid of the Manhattan distance and ''as the crow
flies'' to calculate the \textit{H} cost. If a unit located at the coordinate
(x, y) is trying to reach the end node \textit{E} at coordinate (ex, ey), where
$ x \ne ex \land y \ne ey $ it's safe to assume that diagonal steps may result
in a shorter path in terms of number of steps. For the sake of argument let the
distance of a vertical and horizontal step be one unit and the distance of a
diagonal step be $ \sqrt{2} $ units. We could use this property as our edge cost
\ref{Edge costs} for the A* algorithm. Since the heuristic function will be
executed once for every processed node its performance becomes critical. To
avoid having to calculate the square root of 2 and working with reals we are
using 10 as the edge cost (see section \ref{Edge costs}) of a vertical and
horizontal steps and 14 as the edge cost of diagonal steps. The diagonal edge
cost is derived from: $ \floor{10 \sqrt{1+1}} = 14 $.

To get a feeling for how the diagonal heuristic operates lets take a look at an
example. Let \textit{S} and \textit{E} in figure \ref{fig:grid} represent the
start and end nodes respectively. To walk from \textit{S} to \textit{E} the
shortest path will traverse

\begin{figure}[htbp]
	\centering
	\texttt{+-------+ \\
|.....E.| \\
|.S.....| \\
+-------+}
	\caption{\label{fig:grid} Example grid with the start node \textit{S} at
	coordinate (1, 1) and the end node \textit{E} at coordinate (5, 0).}
\end{figure}

The cost using Manhattan distance between 's' and 'g' is $ 1*10 + 4*10 = 50 $,
since there is one vertical and four horizontal steps from 's' to 'g'.

Using a hybrid heuristic we could combine a horizontal and a vertical step into
a diagonal step which would cost 14 instead of 10+10=20. Using this method the
heuristic could no longer be inadmissible.

The cost using a hybrid heuristic would in this case be $ 1*14 + 3*10 = 44 $,
since there is one diagonal and three horizontal steps from 's' to 'g'.

\textit{Inadmissible heuristics}

% F, G, H costs.

\subsubsection{Edge costs}
\label{Edge costs}

In order to prioritize the processing of nodes the A* algorithm keeps track of
three different cost values for each node in the graph, namely \textit{F},
\text{G} and \text{H}.

The \textit{G} value of a node \textit{C} represents the cost of traversing the
edges from the start node \textit{S} to the current node \textit{C} along a
given path. It is important to note that there may be more than one path from
\textit{S} to \textit{C}; more about this in section \ref{Tracking node visits}.

The \textit{H} value of a node \textit{C} is given by the estimated cost of
traveling from \textit{C} to the end node \textit{E}. This estimation is given
by a heuristic function, which is further described in section \ref{Heuristics}.

The \textit{F} value of a node \textit{C} is given by the sum of the \textit{G}
and \textit{H} cost of \textit{C}.

To summarize:
\begin{itemize}
	\item \textit{F}: $ G + H $.
	\item \textit{G}: the cost of traversing the edges from \textit{S} to
	\textit{C}.
	\item \textit{H}: the estimated cost of traversing the edges from \textit{C}
	to \textit{E}.
\end{itemize}

% Open list, closed list (colors).

\subsubsection{Tracking node visits}
\label{Tracking node visits}

It is important to keep track of visited nodes so that no node is processed more
than once.

% Time complexity.

% ~~~ [ Priority queues ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Priority queues}
\label{Priority queues}

A priority queue is a queue of elements with a priority. The element with the highest priority is always the first element to be taken off the list. We use a value 'key'  for each element to represent the priority, the lower the key the higher the priority. Every element also has a unique identifier which we can use to find an element and update the priority.  There are numerous ways to implement priority queues and we have created two implementations.

\begin{enumerate}
\item{List}\\
A one dimensional list where the elements are ordered by rising key value. Popping the element with the highest priority from the queue is just a matter of taking the first element in the list which is a constant time operation. Elements are inserted at the right position by comparing the key of the element to insert with every consecutive element from the beginning of the list until a element with a higher key value is found. Updating the priority of a element is a matter of looking through the list, element by element, until we find one with a specific identifier, removing that from the list and inserting it again with the new priority. Inserting and updating (remove and insert) are both operations that take linear time because we potentially have to look at every element in the list.

\item{Binomial Heap}\\
A binomial min-heap is a list of binomial trees that satisfy the min-heap property such that the key of each non-root is a least the key of its parent. The number of trees in a binomial heap is at most lg|h|+1 ( h is total number of nodes in all trees). Because finding the node with the lowest key is a matter of looking at the root of each tree, it becomes a O(lg|h|) operation. Inserting a new node also takes O(lg|h|) at worst. Updating a node to have a higher priority is a matter of finding the node and changing its key, then move it up the tree by swapping place with its parents until the key is higher than the parent or it becomes the root. Fully explaining a binomial heap however is not within the scope of this report but more details are available in lecture 28 \cite{lecture28} where our implementation (except update function) also is borrowed from.

\end{enumerate}

\textit{Similarities to Dijkstra}

% The Dijkstra algorithm could be implemented using A* with a heuristic function
% which always returns 0.


% ~~~ [ Multiple shortest paths ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{One out of multiple shortest paths}

When two nodes have the same F score one must be chosen over the other. This
choise will not affect the length of the path, but it may affect the path
itself. Another way to put this is that depending on how ties are treated two
different implementations of the A* algorithm may find different paths of equal
length. \cite{astar2}

% === [ User's Manual ] ========================================================

\section{User's Manual}

The usage of this program is best explained by using an example. This guide also assumes that
the user has floor.txt, object.txt and walkable.txt/ref{tile-grid} in the same folder as the rest of
the sml-files.

A good demonstration of this following process can be found in demo.sml.

The first step the user needs to take is to call \textit{TileGrid.make} with object.txt. This is followed
by using \textit{TileGrid.make} with floor.txt and then merging the two tilegrids with \textit{TileGrid.merge}.
Once these steps have been taken one can move on to creating an actual grid(Grid.grid) by calling
\textit{Grid.make} with the merged object/floor grid and walk.txt.

This grid can be used to create a polymorphic graph object which is used for the actual pathfinding.
The easiest way to create graphs that are compatibile with the two pathfinding algorithms is by using:
\textit{Pathfinder.aStarGraph} for use with aStar and \textit{Pathfinder.dijkstraGraph} for dijkstra.

Once either a aStarGraph or dijkstraGraph has been created the user will have all the tools to
use the pathfinding-algorithms. To do this, all the user needs to do is to call \textit{Pathfinder.aStar}(or
\textit{Pathfinder.dijkstra} for dijkstra) with the aStarGraph, a start coordinate(in the form of x,y and an end coordinate.
If a path is found then \textit{SOME} list containing the coordinates from start to end is returned. Otherwise, if no path has
been found then \textit{NONE} is returned.

After a pathfinding list has been acquired, it is possible to print the map with the path marked. This can be performed by
calling \textit{Pretty.printPath} with: \textit{Grid.Array2}(or \textit{Grid.Vector2} depending on which version)
on the grid that was used to create the graph, the start position, the end location and also the list containing the path.

% === [ Analysis and discussion ] ==============================================

\section{Analysis and discussion}
\label{Analysis}

% Implementation analysis.

% Test cases, how the we verify that the implementation is correct?

% Is there anything that doesn't work. It is possible to walk thorugh diagonal
% walls.

% Benchmarks. Is A* measurabley more performable than Dijkstra. How does the
% performance of list and binomal heaps differ.

\subsection{Future work}

% Preprocess edge costs.

% Disallow diagonal walks through walls.

% Pathfinding in the third dimension.

% Hot queue.

% Formal verifications.

% Make an interlanguage bridge to make the SML API callable from C. ref: mlton

% Make purely functional (if we don't finish this) and measure the performance
% impact.

\pagebreak

\bibliography{references}

\end{document}
